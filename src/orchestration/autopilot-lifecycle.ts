import { promises as fs } from 'node:fs';
import path from 'node:path';

import { runAutopilotSchema } from '../contracts/run.contract.js';
import { isTerminalRunStatus } from '../domain/run-lifecycle.js';
import type { AppPaths } from '../store/paths.js';
import type { Run, RunAutopilot } from '../types/run.js';
import { ensureDir, writeFileAtomic, writeJsonAtomic } from '../utils/fs.js';
import { nowIso } from '../utils/time.js';

type AutopilotReviewer = keyof RunAutopilot['reviews'];

const autopilotReviewers: AutopilotReviewer[] = ['architect', 'security', 'code'];
export const AUTOPILOT_QA_REPEAT_LIMIT = 3;
export const AUTOPILOT_DEFAULT_MAX_QA_CYCLES = 5;
export const AUTOPILOT_DEFAULT_MAX_VALIDATION_ROUNDS = 3;

function toPosixRelative(rootDir: string, targetPath: string): string {
  return path.relative(rootDir, targetPath).split(path.sep).join('/');
}

function buildAutopilotSpecContent(runId: string, goal: string, generatedAt: string): string {
  return `# Autopilot Spec

Generated by Ju Office start flow.

- Run ID: ${runId}
- Goal: ${goal}
- Generated At: ${generatedAt}

## Phase 0 — Expansion
- Expand the goal into explicit product requirements and constraints.
- Capture success criteria for deterministic delivery and investor visibility.

## Phase 1 — Planning
- Convert requirements into an executable implementation plan.
- Partition work into build, QA, and validation tracks.

## Phase 2 — Execution
- Implement planned tasks and record proof-linked outcomes.
- Maintain deterministic snapshots for office visibility.

## Phase 3 — QA
- Require explicit QA result recording (pass/fail) with summary and signature on failures.

## Phase 4 — Validation
- Require architect, security, and code approvals before run completion.
`;
}

function buildAutopilotImplementationContent(runId: string, goal: string, generatedAt: string): string {
  return `# Autopilot Implementation Plan

- Run ID: ${runId}
- Goal: ${goal}
- Generated At: ${generatedAt}

## Plan
1. Start run with deterministic personas, seeded tasks, and autopilot metadata.
2. Execute task lifecycle with proof-gated completion.
3. Enter QA phase once execution is ready for verification.
4. Record QA result via \`qa\` command.
5. Record reviewer decisions via \`review\` command for architect, security, and code.
6. Complete run only when proof gating + QA pass + all approvals are satisfied.
`;
}

function buildAutopilotChecklistContent(runId: string, generatedAt: string): string {
  return `# Autopilot Checklist

- Run ID: ${runId}
- Generated At: ${generatedAt}

- [x] Phase 0 complete: spec generated
- [x] Phase 1 complete: implementation plan generated
- [ ] Phase 2 complete: execution goals met
- [ ] Phase 3 complete: QA pass recorded
- [ ] Phase 4 complete: architect/security/code approvals recorded
- [ ] Completion gate satisfied
`;
}

function checkbox(value: boolean): string {
  return value ? 'x' : ' ';
}

function buildAutopilotChecklistFromRun(run: Run): string {
  const generatedAt = run.updatedAt;
  const phase2Done = ['executing', 'verifying', 'paused', 'blocked', 'completed', 'failed', 'stopped'].includes(run.status);
  const qaDone = run.autopilot?.qa.result === 'pass';
  const reviewsDone = run.autopilot ? hasAutopilotCompletionApproval(run.autopilot) : false;
  const completionDone = run.status === 'completed';

  return `# Autopilot Checklist

- Run ID: ${run.runId}
- Updated At: ${generatedAt}

- [x] Phase 0 complete: spec generated
- [x] Phase 1 complete: implementation plan generated
- [${checkbox(phase2Done)}] Phase 2 complete: execution goals met
- [${checkbox(qaDone)}] Phase 3 complete: QA pass recorded
- [${checkbox(reviewsDone)}] Phase 4 complete: architect/security/code approvals recorded
- [${checkbox(completionDone)}] Completion gate satisfied
`;
}

export async function createAutopilotMetadata(
  paths: AppPaths,
  runId: string,
  goal: string,
  generatedAt = nowIso()
): Promise<RunAutopilot> {
  await ensureDir(paths.omxPlansDir);

  await Promise.all([
    writeFileAtomic(paths.autopilotSpecFile, buildAutopilotSpecContent(runId, goal, generatedAt)),
    writeFileAtomic(paths.autopilotImplFile, buildAutopilotImplementationContent(runId, goal, generatedAt)),
    writeFileAtomic(paths.autopilotChecklistFile, buildAutopilotChecklistContent(runId, generatedAt))
  ]);

  return runAutopilotSchema.parse({
    phase: 'execution',
    state: 'active',
    qa: {
      result: 'pending',
      cyclesCompleted: 0,
      maxCycles: AUTOPILOT_DEFAULT_MAX_QA_CYCLES,
      repeatedFailureCount: 0
    },
    validation: {
      roundsCompleted: 0,
      maxRounds: AUTOPILOT_DEFAULT_MAX_VALIDATION_ROUNDS
    },
    reviews: {
      architect: { decision: 'pending' },
      security: { decision: 'pending' },
      code: { decision: 'pending' }
    },
    planFiles: {
      spec: toPosixRelative(paths.rootDir, paths.autopilotSpecFile),
      implementation: toPosixRelative(paths.rootDir, paths.autopilotImplFile),
      checklist: toPosixRelative(paths.rootDir, paths.autopilotChecklistFile)
    },
    updatedAt: generatedAt
  });
}

export function hasAutopilotCompletionApproval(autopilot: RunAutopilot): boolean {
  if (autopilot.qa.result !== 'pass') {
    return false;
  }
  return autopilotReviewers.every((reviewer) => autopilot.reviews[reviewer].decision === 'approve');
}

function hasRejectedAutopilotReview(autopilot: RunAutopilot): boolean {
  return autopilotReviewers.some((reviewer) => autopilot.reviews[reviewer].decision === 'reject');
}

function deriveAutopilotPhaseAndState(
  runStatus: Run['status'],
  autopilot: RunAutopilot
): Pick<RunAutopilot, 'phase' | 'state'> {
  if (runStatus === 'completed') {
    return { phase: 'complete', state: 'complete' };
  }

  if (hasRejectedAutopilotReview(autopilot)) {
    return { phase: 'validation', state: 'rejected' };
  }

  if (autopilot.qa.result === 'pending') {
    if (runStatus === 'planning') {
      return { phase: 'planning', state: 'active' };
    }

    if (runStatus === 'verifying') {
      return { phase: 'qa', state: 'awaiting_qa' };
    }

    if (runStatus === 'paused' && ['qa', 'validation'].includes(autopilot.phase)) {
      return { phase: 'qa', state: 'awaiting_qa' };
    }

    return { phase: 'execution', state: 'active' };
  }

  if (autopilot.qa.result === 'fail') {
    return { phase: 'qa', state: 'qa_failed' };
  }

  if (hasAutopilotCompletionApproval(autopilot)) {
    return { phase: 'validation', state: 'approved' };
  }

  return { phase: 'validation', state: 'awaiting_review' };
}

export function syncAutopilotLifecycle(run: Run): Run {
  if (!run.autopilot) {
    return run;
  }

  const derived = deriveAutopilotPhaseAndState(run.status, run.autopilot);
  const nextUpdatedAt = run.updatedAt;
  const shouldUpdate =
    run.autopilot.phase !== derived.phase ||
    run.autopilot.state !== derived.state ||
    run.autopilot.updatedAt !== nextUpdatedAt;

  if (!shouldUpdate) {
    return run;
  }

  return {
    ...run,
    autopilot: {
      ...run.autopilot,
      phase: derived.phase,
      state: derived.state,
      updatedAt: nextUpdatedAt
    }
  };
}

export function hasQaEscalationFailure(autopilot: RunAutopilot): boolean {
  return (
    autopilot.qa.cyclesCompleted > autopilot.qa.maxCycles ||
    autopilot.qa.repeatedFailureCount >= AUTOPILOT_QA_REPEAT_LIMIT
  );
}

export function hasValidationEscalationFailure(autopilot: RunAutopilot): boolean {
  return autopilot.validation.roundsCompleted >= autopilot.validation.maxRounds;
}

export async function writeAutopilotStateMirror(paths: AppPaths, run: Run): Promise<void> {
  if (!run.autopilot) {
    return;
  }

  await ensureDir(paths.omxStateDir);
  await writeJsonAtomic(paths.autopilotStateFile, {
    runId: run.runId,
    runStatus: run.status,
    goal: run.goal,
    phase: run.autopilot.phase,
    state: run.autopilot.state,
    qa: run.autopilot.qa,
    validation: run.autopilot.validation,
    reviews: run.autopilot.reviews,
    updatedAt: run.autopilot.updatedAt
  });
}

export async function clearAutopilotStateMirror(paths: AppPaths): Promise<void> {
  try {
    await fs.unlink(paths.autopilotStateFile);
  } catch (error) {
    const code =
      error && typeof error === 'object' && 'code' in error && typeof (error as { code?: unknown }).code === 'string'
        ? ((error as { code: string }).code as string)
        : '';
    if (code !== 'ENOENT') {
      throw error;
    }
  }
}

export async function syncAutopilotStateMirror(paths: AppPaths, run: Run): Promise<void> {
  if (!run.autopilot) {
    await clearAutopilotStateMirror(paths);
    return;
  }

  await ensureDir(paths.omxPlansDir);
  await writeFileAtomic(paths.autopilotChecklistFile, buildAutopilotChecklistFromRun(run));

  if (isTerminalRunStatus(run.status)) {
    await clearAutopilotStateMirror(paths);
    return;
  }

  await writeAutopilotStateMirror(paths, run);
}
